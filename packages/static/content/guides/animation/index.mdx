---
title: 'Declarative Animation'
---

Programming declarative animation is a huge topic, but we'll scratch the surface
in this guide.

# The declarative animation loop

One way you can achieve an animation with `react-babylonjs` is by using the
Engine render loop, which runs many times per second. You can receive callbacks
for this loop by using the `useBeforeRender` hook. As its name implies, it is
called before each frame render and allows you to adjust whatever needs
adjusting.

The beauty of Component based design is that each React component can register
their own animation loop handler and take responsibility just for its small
task. Tasks in common can be hoisted to parent components. In this way, we can
achieve very efficient and organized animations.

Here's some basic usage:

```tsx
const scene = useScene()

useBeforeRender(() => {
  if (scene) {
    // This gets called ~60 FPS
    // Don't do a lot in here, just essentials
  }
})
```

# Degrees of Freedom

Every object in 3D has a _position_ (x, y, z) in space and a _rotation_ (roll,
pitch, yaw). As
[google states it](https://developers.google.com/vr/discover/degrees-of-freedom):

> Three correspond to rotational movement around the x, y, and z axes, commonly
> termed pitch, yaw, and roll. The other three correspond to translational
> movement along those axes, which can be thought of as moving forward or
> backward, moving left or right, and moving up or down.

You can read a lot about this elsewhere, so we won't cover it in much depth
here. The main point to take away is that animation involves affecting one or
more of these degrees of freedom on each object (animations can also be for
colors, etc.).

Let's try `useBeforeRender` to adjust these properties.

# Creating the famous rotating box

Using a box as an example - we will rotate it about the Y axis, known as _yaw_.
And, we'll do it many times per second.

Here's how to make a box (`<box ... />` calls the babylon.js
[CreateBox method](https://doc.babylonjs.com/typedoc/modules/BABYLON#CreateBox-2).
We need to make sure we are passing required constructor (or factory method)
arguments.

- Only `name` is required - the `Scene` object will be passed for you
  automatically.
- Properties of the returned object of type `Mesh` can be set as well (ie:
  `position`, `rotation`). Changes to those properties will flow to the
  underling mesh - just like changing a DOM element attribute works.

```tsx
<box name="box" size={2} position={new Vector3(0, 1, 0)} />
```

[devtool:LoneBox.tsx]

Now to make it spin. We will make the box spin about the Y axis. From
[Mesh rotation in Babylon](https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation)
we see that the Y axis is the vertical axis.

To achieve animation, we have to alter the box's Y rotation. Ok, let's do it.
First let's try using state, so we need a state variable to hold the Y value:

```tsx
const [y, setY] = useState(0)
```

Then, we need to alter it in the render loop:

```tsx
useBeforeRender(() => {
  setY((oldY) => oldY + 0.1)
})
```

To put everything together, we can create a Functional Component (FC) that wraps
the `box` tag with our new behaviors.

```tsx
import { Vector3 } from '@babylonjs/core/Maths/math.vector'
import React, { FC, useState } from 'react'
import { useBeforeRender } from 'react-babylonjs'

const RotatingBox: FC = () => {
  const [y, setY] = useState(0)
  useBeforeRender(() => {
    setY((oldY) => oldY + 0.1)
  })
  return (
    <box
      name="box"
      size={2}
      position={Vector3(0, 1, 0)}
      rotation={Vector3(0, y, 0)}
    />
  )
}
```

[devtool:BasicScene.tsx]

# Using real-world timing in animations

The rotatin box is fun, but it would be nice to specify its rotation speed in
term so of real-world time.

Let's adjust the rotation to Revolutions Per Minute (RPM). To do that, we need
to know that one complete revolution of _yaw_ is `pi \* 2`.

We also need to know how many milliseconds have passed between animation frames.
Fortunately Babylon.js provides a `getDeltaTime()` that tells us exactly that.
Using all that information, we can do this instead:

```tsx
const RPM = 5
setY((oldY) => oldY + (RPM / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000))
```

# Making `rpm` a component prop

Let's use the power of Typescript to create some spinning box props that accepts
RPM:

```tsx
type RotatingBoxProps = {
  rpm: number
}
```

This will be the props that we pass to the box. Let's update the box component
to use it:

```tsx
const RotatingBox: FC<RotatingBoxProps> = ({ rpm }) => ...
```

And then update the hook:

```tsx
useBeforeRender(() => {
  // ...
  setY((oldY) => oldY + (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000))
})
```

Now that's a nice reactive component! We use it like this:

```tsx
<RotatingBox rpm={60} />
```

Let's try it. We should see one rotation per second when `rpm` is 60.

[devtool:RPMBox.tsx]

# Making `rpm` even more reactive

In the interests of completeness, you might notice the hook is referring to
`rpm`. If `rpm` were to change, we would want to make sure that new value took
effect. Therefore, just like `useEffect`, `rpm` is a dependency:

```tsx
useBeforeRender(
  () => {
    // ...
  },
  undefined,
  undefined,
  undefined,
  [rpm]
)
```

[devtool:RPMBox3.tsx]

# Adding a debugging experience

It would be very cool if we had a way to interact with the application state for
debugging purposes.

There are a couple ways to accomplish this:

1. Outside the scene, using standard web technologies
2. Inside the scene, using a GUI capable of rendering in 3D space

Let's go with option #1 for now.
